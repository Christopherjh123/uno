<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uno Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            overflow: hidden; /* Prevent body scroll */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
            max-width: 1000px;
            margin: auto;
            border-radius: 1rem;
            background-color: #2d3748; /* Slightly lighter dark background for game area */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
            position: relative;
        }

        .card {
            width: 5.5rem; /* ~88px */
            height: 8rem; /* ~128px */
            border-radius: 0.75rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 2.25rem; /* 36px */
            cursor: pointer;
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
            user-select: none; /* Prevent text selection on cards */
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 2px solid transparent; /* Default border */
        }

        .card:hover:not(.disabled):not(.deck-card) {
            transform: translateY(-0.5rem);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }

        .card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Card Colors */
        .bg-red { background-color: #ef4444; color: white; } /* Red 500 */
        .bg-blue { background-color: #3b82f6; color: white; } /* Blue 500 */
        .bg-green { background-color: #22c55e; color: white; } /* Green 500 */
        .bg-yellow { background-color: #eab308; color: white; } /* Yellow 500 */
        .bg-black { background-color: #1f2937; color: white; } /* Gray 800 for wild */
        .bg-card-back { background-color: #dc2626; color: white; } /* Red 600 for card back */

        /* Specific card styles */
        .card-value {
            line-height: 1;
        }

        .card-action-icon {
            font-size: 1.5rem; /* 24px */
            line-height: 1;
        }

        .card-wild-text {
            font-size: 1.25rem; /* 20px */
            text-align: center;
            line-height: 1.2;
        }

        .card.highlighted {
            border-color: #38bdf8; /* Sky 400 */
            box-shadow: 0 0 0 4px #38bdf8;
        }

        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            min-height: 9rem; /* Ensure space even with no cards */
        }

        .game-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            padding: 1rem 0;
        }

        .deck-area, .discard-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .deck-card {
            background-color: #dc2626; /* Red 600 */
            color: white;
            font-size: 1.5rem;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateY(180deg); /* Show back of card */
            transition: transform 0.3s ease-out;
        }

        .deck-card::before {
            content: 'UNO';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotateY(180deg); /* Flip text back */
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
        }

        .discard-pile .card {
            transform: rotate(0deg); /* Reset rotation for played card */
        }

        .message-box {
            background-color: #4a5568; /* Gray 700 */
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            text-align: center;
            font-size: 1.125rem; /* 18px */
            min-height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            font-size: 1.125rem;
            font-weight: bold;
        }

        .player-info.current-player {
            color: #63b3ed; /* Blue 400 */
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 500px;
            width: 90%;
            position: relative;
        }

        .color-option {
            width: 4rem;
            height: 4rem;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s ease-in-out;
            border: 3px solid transparent;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: #e2e8f0; /* Light border for selected */
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .card {
                width: 4.5rem; /* Smaller cards on mobile */
                height: 6.5rem;
                font-size: 1.75rem;
            }
            .card-action-icon {
                font-size: 1.2rem;
            }
            .card-wild-text {
                font-size: 1rem;
            }
            .game-area {
                flex-direction: column;
                gap: 1rem;
            }
            .hand {
                gap: 0.3rem;
            }
            .color-option {
                width: 3rem;
                height: 3rem;
            }
        }

        /* Button styling */
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: none;
        }

        .btn-primary {
            background-color: #4299e1; /* Blue 500 */
            color: white;
        }

        .btn-primary:hover {
            background-color: #3182ce; /* Blue 600 */
            transform: translateY(-1px);
        }

        .btn-secondary {
            background-color: #a0aec0; /* Gray 400 */
            color: #2d3748;
        }

        .btn-secondary:hover {
            background-color: #718096; /* Gray 500 */
            transform: translateY(-1px);
        }

        .uno-button {
            background-color: #f6ad55; /* Orange 400 */
            color: white;
            font-size: 1.125rem;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: none;
        }

        .uno-button:hover:not(.disabled) {
            background-color: #ed8936; /* Orange 500 */
            transform: translateY(-1px);
        }

        .uno-button.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
    </style>
    <link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#4CAF50">
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-4xl font-bold mb-6 text-blue-400">UNO!</h1>

    <div id="game-container" class="game-container">
        <div class="player-info flex justify-between items-center mb-4" id="bot-info">
            <span class="text-xl font-semibold">Bot's Hand: <span id="bot-card-count">0</span> cards</span>
        </div>

        <div class="game-area flex justify-center items-center gap-8">
            <div class="deck-area flex flex-col items-center">
                <div id="deck" class="card deck-card cursor-pointer"></div>
                <span class="text-sm mt-2">Draw Pile</span>
            </div>
            <div class="discard-area flex flex-col items-center">
                <div id="discard-pile" class="card bg-gray-800 flex items-center justify-center text-white text-3xl">
                    <span class="text-lg">Discard</span>
                </div>
                <span class="text-sm mt-2">Discard Pile</span>
            </div>
        </div>

        <div id="message-box" class="message-box mt-4 mb-4">
            Welcome to Uno! Click 'Start Game' to begin.
        </div>

        <div class="player-info flex justify-between items-center mt-4" id="player-info">
            <span class="text-xl font-semibold">Your Hand: <span id="player-card-count">0</span> cards</span>
            <button id="uno-button" class="uno-button disabled">UNO!</button>
        </div>
        <div id="player-hand" class="hand mb-4">
            </div>

        <div class="flex justify-center mt-4 gap-4">
            <button id="start-game-button" class="btn btn-primary">Start Game</button>
            <button id="reset-game-button" class="btn btn-secondary hidden">Reset Game</button>
        </div>
    </div>

    <div id="color-picker-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-6">Choose a Color</h2>
            <div class="flex justify-center gap-4 mb-6">
                <div class="color-option bg-red" data-color="red"></div>
                <div class="color-option bg-blue" data-color="blue"></div>
                <div class="color-option bg-green" data-color="green"></div>
                <div class="color-option bg-yellow" data-color="yellow"></div>
            </div>
        </div>
    </div>

    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="game-over-message" class="text-3xl font-bold mb-4"></h2>
            <button id="play-again-button" class="btn btn-primary mt-4">Play Again</button>
        </div>
    </div>

    <script>
        // --- Game State Variables ---
        let deck = [];
        let discardPile = [];
        let playerHand = [];
        let botHand = [];
        let currentPlayer = 'player'; // 'player' or 'bot'
        let gameDirection = 1; // 1 for clockwise, -1 for counter-clockwise
        let currentCard = null;
        let unoCalled = { player: false, bot: false };
        let gameActive = false;
        let botThinkingTimeout = null;
        let skipNextTurnFlag = false; // Flag to indicate if the next turn should be skipped

        // --- DOM Elements ---
        const deckElement = document.getElementById('deck');
        const discardPileElement = document.getElementById('discard-pile');
        const playerHandElement = document.getElementById('player-hand');
        const botCardCountElement = document.getElementById('bot-card-count');
        const playerCardCountElement = document.getElementById('player-card-count');
        const messageBox = document.getElementById('message-box');
        const colorPickerModal = document.getElementById('color-picker-modal');
        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverMessage = document.getElementById('game-over-message');
        const startGameButton = document.getElementById('start-game-button');
        const resetGameButton = document.getElementById('reset-game-button');
        const playAgainButton = document.getElementById('play-again-button');
        const unoButton = document.getElementById('uno-button');
        const botInfo = document.getElementById('bot-info');
        const playerInfo = document.getElementById('player-info');

        // --- Card Data Structure ---
        const colors = ['red', 'blue', 'green', 'yellow'];
        const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const actionCards = ['skip', 'reverse', 'draw2']; // +2
        const wildCards = ['wild', 'wild4']; // Wild, +4

        // --- Game Functions ---

        /**
         * Creates a standard Uno deck.
         * A standard Uno deck has 108 cards:
         * - 19 of each color (red, blue, green, yellow): one 0, two of 1-9
         * - 2 of each action card (Skip, Reverse, Draw Two) in each color
         * - 4 Wild cards
         * - 4 Wild Draw Four cards
         */
        function createDeck() {
            let newDeck = [];

            // Number cards
            colors.forEach(color => {
                newDeck.push({ color: color, value: '0', type: 'number' }); // One '0' card
                for (let i = 1; i <= 9; i++) {
                    newDeck.push({ color: color, value: String(i), type: 'number' }); // Two of 1-9
                    newDeck.push({ color: color, value: String(i), type: 'number' });
                }
            });

            // Action cards (Skip, Reverse, Draw Two)
            colors.forEach(color => {
                actionCards.forEach(action => {
                    newDeck.push({ color: color, value: action, type: 'action' }); // Two of each action card
                    newDeck.push({ color: color, value: action, type: 'action' });
                });
            });

            // Wild cards
            wildCards.forEach(wild => {
                for (let i = 0; i < 4; i++) {
                    newDeck.push({ color: 'black', value: wild, type: 'wild' });
                }
            });

            return newDeck;
        }

        /**
         * Shuffles the given deck using the Fisher-Yates algorithm.
         * @param {Array} deck - The array of cards to shuffle.
         * @returns {Array} The shuffled deck.
         */
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]]; // Swap elements
            }
            return deck;
        }

        /**
         * Deals initial cards to players.
         */
        function dealInitialCards() {
            playerHand = [];
            botHand = [];
            for (let i = 0; i < 7; i++) {
                drawCard('player', 1);
                drawCard('bot', 1);
            }
        }

        /**
         * Draws a specified number of cards for a player.
         * If the deck is empty, shuffles the discard pile back into the deck.
         * @param {string} playerType - 'player' or 'bot'.
         * @param {number} count - Number of cards to draw.
         */
        function drawCard(playerType, count) {
            let hand = playerType === 'player' ? playerHand : botHand;
            for (let i = 0; i < count; i++) {
                if (deck.length === 0) {
                    if (discardPile.length <= 1) {
                        // No cards left to draw and only the current card in discard pile
                        showMessage("No cards left in deck or discard pile. Game might be stuck.");
                        return; // Cannot draw more cards
                    }
                    // Reshuffle discard pile into deck, keeping the top card on discard
                    const topDiscardCard = discardPile.pop();
                    deck = shuffleDeck(discardPile);
                    discardPile = [topDiscardCard];
                    showMessage("Deck reshuffled from discard pile!");
                }
                const card = deck.pop();
                if (card) {
                    hand.push(card);
                }
            }
            renderHands();
        }

        /**
         * Renders the player's and bot's hands on the UI.
         */
        function renderHands() {
            playerHandElement.innerHTML = '';
            playerHand.forEach((card, index) => {
                const cardElement = createCardElement(card, index);
                if (currentPlayer === 'player' && isValidPlay(card)) {
                    cardElement.classList.add('highlighted'); // Highlight playable cards
                } else if (currentPlayer === 'player') {
                    cardElement.classList.add('disabled'); // Disable unplayable cards
                }
                playerHandElement.appendChild(cardElement);
            });
            playerCardCountElement.textContent = playerHand.length;
            botCardCountElement.textContent = botHand.length;
        }

        /**
         * Creates an HTML element for a card.
         * @param {object} card - The card object { color, value, type }.
         * @param {number} index - The index of the card in the hand (for player cards).
         * @returns {HTMLElement} The card div element.
         */
        function createCardElement(card, index = -1) {
            const cardElement = document.createElement('div');
            cardElement.classList.add('card', `bg-${card.color}`);
            if (index !== -1) {
                cardElement.dataset.index = index; // Store index for player hand
            }

            let cardContent = '';
            if (card.type === 'number') {
                cardContent = `<span class="card-value">${card.value}</span>`;
            } else if (card.type === 'action') {
                let icon = '';
                if (card.value === 'skip') icon = 'ðŸš«';
                else if (card.value === 'reverse') icon = 'ðŸ”„';
                else if (card.value === 'draw2') icon = '+2';
                cardContent = `<span class="card-action-icon">${icon}</span>`;
            } else if (card.type === 'wild') {
                let text = '';
                if (card.value === 'wild') text = 'WILD';
                else if (card.value === 'wild4') text = '+4<br>WILD';
                cardContent = `<span class="card-wild-text">${text}</span>`;
            }
            cardElement.innerHTML = cardContent;
            return cardElement;
        }

        /**
         * Renders the top card of the discard pile.
         */
        function renderDiscardPile() {
            discardPileElement.innerHTML = '';
            if (currentCard) {
                const cardElement = createCardElement(currentCard);
                // Ensure the discard pile card is not clickable or highlighted
                cardElement.classList.remove('highlighted', 'disabled');
                cardElement.classList.add(`bg-${currentCard.color}`); // Ensure color is set
                discardPileElement.appendChild(cardElement);
            } else {
                discardPileElement.innerHTML = '<span class="text-lg">Discard</span>';
                discardPileElement.classList.remove(...colors.map(c => `bg-${c}`));
                discardPileElement.classList.add('bg-gray-800');
            }
        }

        /**
         * Checks if a card can be played on the current card.
         * @param {object} card - The card to check.
         * @returns {boolean} True if the card is playable, false otherwise.
         */
        function isValidPlay(card) {
            if (!currentCard) return true; // Should only happen at the very start of the game

            // Wild cards can always be played
            if (card.type === 'wild') return true;

            // Match color or value
            return card.color === currentCard.color || card.value === currentCard.value;
        }

        /**
         * Handles playing a card.
         * @param {string} playerType - 'player' or 'bot'.
         * @param {object} card - The card object being played.
         * @param {number} cardIndex - The index of the card in the hand (for removing).
         */
        function playCard(playerType, card, cardIndex) {
            let hand = playerType === 'player' ? playerHand : botHand;

            // Remove card from hand
            hand.splice(cardIndex, 1);
            discardPile.push(card);
            currentCard = { ...card }; // Create a copy to avoid modifying the card in discardPile array later

            // Reset Uno call status for the current player
            unoCalled[playerType] = false;

            // Apply card effects - this might trigger color picker or draw cards
            const requiresColorChoice = applyCardEffect(card, playerType); // Returns true if color choice is needed

            // Update UI
            renderHands();
            renderDiscardPile();

            // Check for win condition
            if (hand.length === 0) {
                endGame(playerType);
                return;
            }

            // Check for Uno condition
            if (hand.length === 1) {
                showMessage(`${playerType === 'player' ? 'You' : 'Bot'} has one card left!`);
                // If it's the bot, it automatically calls Uno.
                // If it's the player, they need to click the Uno button.
                if (playerType === 'bot') {
                    unoCalled.bot = true;
                    showMessage("Bot calls UNO!");
                } else {
                    unoButton.classList.remove('disabled');
                }
            } else {
                 unoButton.classList.add('disabled'); // Disable Uno button if not 1 card left
            }

            // Only proceed to next turn if no color choice is pending.
            // For bot, nextTurn is called inside applyCardEffect after color choice.
            // For player, nextTurn is called inside chooseColor after color choice.
            if (!requiresColorChoice) {
                setTimeout(() => {
                    nextTurn();
                }, 700); // Short delay to see the card played
            }
        }

        /**
         * Applies the effect of the played card.
         * @param {object} card - The card object.
         * @param {string} playerType - 'player' or 'bot'.
         * @returns {boolean} True if a color choice is required (for player wild cards).
         */
        function applyCardEffect(card, playerType) {
            let requiresColorChoice = false;

            if (card.type === 'action') {
                if (card.value === 'skip') {
                    showMessage(`${playerType === 'player' ? 'You' : 'Bot'} played a Skip card! Next player's turn is skipped.`);
                    skipNextTurnFlag = true; // Set flag to skip the next player
                } else if (card.value === 'reverse') {
                    showMessage(`${playerType === 'player' ? 'You' : 'Bot'} played a Reverse card! Direction changed.`);
                    gameDirection *= -1;
                } else if (card.value === 'draw2') {
                    showMessage(`${playerType === 'player' ? 'You' : 'Bot'} played a +2 card! Next player draws 2 cards.`);
                    const nextPlayer = getNextPlayer(false); // Get the player who will draw
                    drawCard(nextPlayer, 2);
                    skipNextTurnFlag = true; // Skip the player who drew cards
                }
            } else if (card.type === 'wild') {
                if (card.value === 'wild') {
                    showMessage(`${playerType === 'player' ? 'You' : 'Bot'} played a Wild card.`);
                    if (playerType === 'player') {
                        requiresColorChoice = true;
                        showColorPicker();
                    } else {
                        // Bot chooses color immediately
                        const chosenColor = botChooseColor(botHand);
                        currentCard.color = chosenColor;
                        showMessage(`Bot chose ${chosenColor.toUpperCase()}!`);
                        setTimeout(() => { // Add a small delay for bot's color choice message
                            nextTurn(); // Bot's turn ends after choosing color
                        }, 500);
                    }
                } else if (card.value === 'wild4') {
                    showMessage(`${playerType === 'player' ? 'You' : 'Bot'} played a +4 Wild card! Next player draws 4 cards.`);
                    const nextPlayer = getNextPlayer(false); // Get the player who will draw
                    drawCard(nextPlayer, 4);
                    skipNextTurnFlag = true; // Skip the player who drew cards

                    if (playerType === 'player') {
                        requiresColorChoice = true;
                        showColorPicker();
                    } else {
                        // Bot chooses color immediately
                        const chosenColor = botChooseColor(botHand);
                        currentCard.color = chosenColor;
                        showMessage(`Bot chose ${chosenColor.toUpperCase()}!`);
                        setTimeout(() => {
                            nextTurn(); // Bot's turn ends after choosing color
                        }, 500);
                    }
                }
            }
            return requiresColorChoice;
        }

        /**
         * Determines the next player based on game direction,
         * and applies skip if skipNextTurnFlag is true.
         * This function also updates the `currentPlayer` global variable.
         */
        function getNextPlayer() {
            let nextPlayerCandidate;
            if (gameDirection === 1) { // Clockwise
                nextPlayerCandidate = (currentPlayer === 'player' ? 'bot' : 'player');
            } else { // Counter-clockwise
                nextPlayerCandidate = (currentPlayer === 'player' ? 'bot' : 'player');
            }

            if (skipNextTurnFlag) {
                // If a skip is active, skip *this* candidate and get the one after them
                skipNextTurnFlag = false; // Consume the flag
                currentPlayer = (nextPlayerCandidate === 'player' ? 'bot' : 'player');
            } else {
                currentPlayer = nextPlayerCandidate;
            }
            return currentPlayer; // Return the new current player
        }

        /**
         * Advances to the next player's turn.
         */
        function nextTurn() {
            // Clear any pending bot thinking timeout
            if (botThinkingTimeout) {
                clearTimeout(botThinkingTimeout);
                botThinkingTimeout = null;
            }

            // Determine and set the next player
            getNextPlayer();

            // Update current player highlight
            if (currentPlayer === 'player') {
                playerInfo.classList.add('current-player');
                botInfo.classList.remove('current-player');
            } else {
                botInfo.classList.add('current-player');
                playerInfo.classList.remove('current-player');
            }

            showMessage(`${currentPlayer === 'player' ? 'Your' : 'Bot\'s'} turn!`);
            renderHands(); // Re-render hands to update playable card highlighting

            if (currentPlayer === 'bot') {
                botThinkingTimeout = setTimeout(botPlay, 1500); // Bot "thinks" for a bit
            }
        }

        /**
         * Logic for the bot to play its turn.
         */
        function botPlay() {
            const playableCards = botHand.filter(card => isValidPlay(card));

            if (playableCards.length > 0) {
                // Simple bot strategy:
                // 1. Prioritize matching color/number cards.
                // 2. Prefer action cards (Skip, Reverse, Draw2) if they match.
                // 3. Use Wild cards if no other options, or strategically.
                // 4. Use Wild Draw Four only if no other valid moves.

                let cardToPlay = null;

                // Try to play a non-wild card first
                const nonWildPlayable = playableCards.filter(card => card.type !== 'wild');
                if (nonWildPlayable.length > 0) {
                    // Prefer action cards over number cards if available
                    const actionPlayable = nonWildPlayable.filter(card => card.type === 'action');
                    if (actionPlayable.length > 0) {
                        cardToPlay = actionPlayable[0]; // Play the first action card found
                    } else {
                        cardToPlay = nonWildPlayable[0]; // Play the first number card found
                    }
                } else {
                    // Only wild cards are playable
                    const wildPlayable = playableCards.filter(card => card.type === 'wild');
                    if (wildPlayable.length > 0) {
                        // Prefer regular wild over wild4 if there are other options to play later
                        const regularWild = wildPlayable.find(card => card.value === 'wild');
                        const wild4 = wildPlayable.find(card => card.value === 'wild4');

                        if (regularWild) {
                            cardToPlay = regularWild;
                        } else if (wild4) {
                            cardToPlay = wild4;
                        }
                    }
                }

                if (cardToPlay) {
                    const cardIndex = botHand.indexOf(cardToPlay);
                    showMessage(`Bot played a ${cardToPlay.value.toUpperCase()} ${cardToPlay.color !== 'black' ? cardToPlay.color.toUpperCase() : ''} card.`);
                    playCard('bot', cardToPlay, cardIndex);
                    if (botHand.length === 1 && !unoCalled.bot) {
                        unoCalled.bot = true;
                        showMessage("Bot calls UNO!");
                    }
                }
            } else {
                // Bot cannot play, draws a card
                showMessage("Bot draws a card.");
                drawCard('bot', 1);
                // After drawing, check if the drawn card can be played.
                // If so, play it. Otherwise, pass turn.
                const drawnCard = botHand[botHand.length - 1]; // The last card drawn
                if (isValidPlay(drawnCard)) {
                    showMessage("Bot plays the drawn card.");
                    playCard('bot', drawnCard, botHand.length - 1);
                } else {
                    showMessage("Bot passes turn.");
                    nextTurn(); // Pass turn if drawn card is not playable
                }
            }
        }

        /**
         * Bot chooses a color after playing a wild card.
         * Chooses the color it has the most cards of.
         * @param {Array} hand - The bot's hand.
         * @returns {string} The chosen color.
         */
        function botChooseColor(hand) {
            const colorCounts = { red: 0, blue: 0, green: 0, yellow: 0 };
            hand.forEach(card => {
                if (colors.includes(card.color)) {
                    colorCounts[card.color]++;
                }
            });

            let maxCount = -1;
            let chosenColor = colors[Math.floor(Math.random() * colors.length)]; // Default to random if no clear majority

            for (const color in colorCounts) {
                if (colorCounts[color] > maxCount) {
                    maxCount = colorCounts[color];
                    chosenColor = color;
                }
            }
            return chosenColor;
        }

        /**
         * Displays the color picker modal for wild cards.
         */
        function showColorPicker() {
            colorPickerModal.classList.add('active');
        }

        /**
         * Hides the color picker modal.
         */
        function hideColorPicker() {
            colorPickerModal.classList.remove('active');
        }

        /**
         * Sets the chosen color for a wild card.
         * @param {string} color - The chosen color.
         */
        function chooseColor(color) {
            currentCard.color = color;
            showMessage(`Color changed to ${color.toUpperCase()}!`);
            hideColorPicker();
            // This is only called for the player, so we can directly call nextTurn here.
            setTimeout(() => { // Add a small delay for color choice message
                nextTurn();
            }, 500);
        }

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         */
        function showMessage(message) {
            messageBox.textContent = message;
        }

        /**
         * Ends the game and displays the winner.
         * @param {string} winner - 'player' or 'bot'.
         */
        function endGame(winner) {
            gameActive = false;
            let message = '';
            if (winner === 'player') {
                message = "Congratulations! You won the game!";
            } else {
                message = "Bot won! Better luck next time!";
            }
            gameOverMessage.textContent = message;
            gameOverModal.classList.add('active');
            resetGameButton.classList.remove('hidden');
            startGameButton.classList.add('hidden');
            unoButton.classList.add('disabled'); // Disable Uno button
            clearTimeout(botThinkingTimeout); // Clear any pending bot turn
        }

        /**
         * Resets the game to its initial state.
         */
        function resetGame() {
            deck = [];
            discardPile = [];
            playerHand = [];
            botHand = [];
            currentPlayer = 'player';
            gameDirection = 1;
            currentCard = null;
            unoCalled = { player: false, bot: false };
            gameActive = false;
            skipNextTurnFlag = false;
            clearTimeout(botThinkingTimeout);
            botThinkingTimeout = null;

            playerHandElement.innerHTML = '';
            discardPileElement.innerHTML = '<span class="text-lg">Discard</span>';
            discardPileElement.classList.remove(...colors.map(c => `bg-${c}`));
            discardPileElement.classList.add('bg-gray-800');
            botCardCountElement.textContent = '0';
            playerCardCountElement.textContent = '0';
            showMessage("Welcome to Uno! Click 'Start Game' to begin.");
            hideColorPicker();
            gameOverModal.classList.remove('active');
            startGameButton.classList.remove('hidden');
            resetGameButton.classList.add('hidden');
            unoButton.classList.add('disabled');
            playerInfo.classList.remove('current-player');
            botInfo.classList.remove('current-player');
        }

        /**
         * Initializes and starts a new game.
         */
        function startGame() {
            resetGame(); // Ensure a clean slate
            deck = shuffleDeck(createDeck());

            // Draw initial discard pile card (must not be a wild4)
            do {
                currentCard = deck.pop();
            } while (currentCard && currentCard.value === 'wild4'); // Cannot start with a +4 Wild

            discardPile.push(currentCard); // Add the first card to discard pile

            if (currentCard.type === 'wild') {
                // If first card is Wild, player chooses color immediately
                showMessage("First card is a Wild! Choose a starting color.");
                showColorPicker();
                // The game will truly start after the color is chosen.
                // For now, set a default color for currentCard until player chooses.
                currentCard.color = 'black'; // Temporarily black for visual
            } else if (currentCard.type === 'action') {
                // Apply initial action card effects
                if (currentCard.value === 'skip') {
                    showMessage("First card is a Skip! Player's first turn is skipped.");
                    currentPlayer = 'bot'; // Bot starts
                } else if (currentCard.value === 'reverse') {
                    showMessage("First card is a Reverse! Direction reversed.");
                    gameDirection *= -1;
                    // If reverse is played on first card, player still starts, but direction is reversed
                    // No change to currentPlayer for initial reverse
                } else if (currentCard.value === 'draw2') {
                    showMessage("First card is a +2! Player draws 2 cards.");
                    drawCard('player', 2);
                    currentPlayer = 'bot'; // Bot starts
                }
            }

            dealInitialCards();
            renderDiscardPile();
            renderHands();

            gameActive = true;
            startGameButton.classList.add('hidden');
            resetGameButton.classList.remove('hidden');

            // If the game didn't start with a wild card requiring color choice, proceed to first turn
            if (!(currentCard.type === 'wild' && currentCard.value === 'wild')) {
                 showMessage(`${currentPlayer === 'player' ? 'Your' : 'Bot\'s'} turn!`);
                 if (currentPlayer === 'player') {
                     playerInfo.classList.add('current-player');
                 } else {
                     botInfo.classList.add('current-player');
                     botThinkingTimeout = setTimeout(botPlay, 1500);
                 }
            }
        }

        // --- Event Listeners ---

        // Player plays a card
        playerHandElement.addEventListener('click', (event) => {
            if (!gameActive || currentPlayer !== 'player') {
                showMessage("It's not your turn!");
                return;
            }

            const cardElement = event.target.closest('.card');
            if (!cardElement || cardElement.classList.contains('disabled')) {
                return; // Not a card or disabled card
            }

            const cardIndex = parseInt(cardElement.dataset.index);
            const cardToPlay = playerHand[cardIndex];

            if (isValidPlay(cardToPlay)) {
                playCard('player', cardToPlay, cardIndex);
                // Reset the "drawn and can play" flag if a card is played
                deckElement.dataset.drawnAndCanPlay = 'false';
            } else {
                showMessage("You cannot play that card!");
            }
        });

        // Player draws a card or passes turn after drawing
        deckElement.addEventListener('click', () => {
            if (!gameActive || currentPlayer !== 'player') {
                showMessage("It's not your turn!");
                return;
            }

            // If player has already drawn a card and can play/pass (second click on deck)
            if (deckElement.dataset.drawnAndCanPlay === 'true') {
                showMessage("You chose to pass your turn.");
                deckElement.dataset.drawnAndCanPlay = 'false'; // Reset flag
                nextTurn();
                return; // Exit after passing
            }

            // If player hasn't drawn yet (first click on deck)
            const playableCardsInHand = playerHand.filter(card => isValidPlay(card));
            if (playableCardsInHand.length > 0) {
                showMessage("You have playable cards, but you chose to draw.");
            }

            showMessage("You drew a card.");
            drawCard('player', 1);
            const drawnCard = playerHand[playerHand.length - 1]; // The card just drawn

            if (isValidPlay(drawnCard)) {
                showMessage("You drew a playable card. Click it to play, or click the deck again to pass.");
                renderHands(); // Re-render to highlight it
                deckElement.dataset.drawnAndCanPlay = 'true'; // Set flag
            } else {
                showMessage("You drew a card and cannot play. Turn passed.");
                nextTurn();
            }
        });

        // Player calls Uno
        unoButton.addEventListener('click', () => {
            if (!gameActive || currentPlayer !== 'player') {
                showMessage("It's not your turn!");
                return;
            }
            if (playerHand.length === 1) {
                unoCalled.player = true;
                showMessage("You called UNO!");
                unoButton.classList.add('disabled');
            } else {
                showMessage("You can only call UNO when you have one card left!");
            }
        });

        // Color picker selection
        colorPickerModal.addEventListener('click', (event) => {
            const colorOption = event.target.closest('.color-option');
            if (colorOption) {
                const chosenColor = colorOption.dataset.color;
                chooseColor(chosenColor);
            }
        });

        // Start Game button
        startGameButton.addEventListener('click', startGame);

        // Reset Game button
        resetGameButton.addEventListener('click', resetGame);

        // Play Again button in Game Over modal
        playAgainButton.addEventListener('click', startGame);

        // Initial setup on load
        resetGame();
    </script>
    <script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(reg => console.log('Service Worker registered!', reg))
      .catch(err => console.log('Service Worker registration failed: ', err));
  });
}
</script>
</body>
</html>
