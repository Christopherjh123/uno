<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Peer-to-Peer UNO</title>
<style>
  body { font-family: sans-serif; margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center; background: #282c34; color: white; }
  #game { display: flex; gap: 20px; margin-top: 20px; }
  #draw, .card { border: 1px solid white; padding: 10px; cursor: pointer; border-radius: 5px; }
  .card.red { background: red; }
  .card.green { background: green; }
  .card.blue { background: blue; }
  .card.yellow { background: yellow; }
  .card.black { background: black; color: white; }
  #hand, #opponent { display: flex; gap: 5px; flex-wrap: wrap; }
</style>
</head>
<body>
<h1>Peer-to-Peer UNO</h1>
<div>
  <textarea id="localSignal" placeholder="Your Signal" rows="5" cols="50"></textarea><br>
  <textarea id="remoteSignal" placeholder="Paste Remote Signal Here" rows="5" cols="50"></textarea><br>
  <button onclick="connect()">Connect</button>
</div>
<div id="game" style="display:none">
  <div id="opponent"></div>
  <div id="draw">ðŸ‚ </div>
  <div id="hand"></div>
</div>
<script>
let deck = [], hands = [[], []], discard = [], turn = 0, dir = 1;
let pendingDraw = 0, chosenColor = null, winner = -1;
let unoSaid = [false, false], mustCallUno = [false, false];
const COLORS = ['red', 'green', 'blue', 'yellow'], VALUES = ['0','1','2','3','4','5','6','7','8','9','Skip','Reverse','Draw2'];
const FULL_DECK = (() => {
  let d = [];
  for (let c of COLORS) {
    d.push({color:c, value:'0'});
    for (let v of VALUES.slice(1)) {
      d.push({color:c, value:v}, {color:c, value:v});
    }
  }
  for (let i = 0; i < 4; i++) d.push({color:'black', value:'Wild'}, {color:'black', value:'WildDraw4'});
  return d;
})();
function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { let j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } }
function deal() {
  deck = [...FULL_DECK]; shuffle(deck);
  hands[0] = deck.splice(0, 7);
  hands[1] = deck.splice(0, 7);
  discard.push(deck.pop());
  chosenColor = discard[0].color;
}
function updateUI() {
  document.getElementById("hand").innerHTML = hands[0].map((c, i) => `<div class="card ${c.color}" onclick="playCard(${i})">${c.value}</div>`).join('');
  document.getElementById("opponent").innerHTML = hands[1].map(() => `<div class="card">ðŸ‚ </div>`).join('');
}
function playCard(i) {
  if (turn !== 0 || winner !== -1) return;
  let card = hands[0][i];
  if (card.color !== chosenColor && card.value !== discard[discard.length - 1].value && card.color !== 'black') return;

  if (card.color === 'black') {
    chosenColor = prompt("Choose color: red, green, blue, yellow", COLORS[0]);
  } else {
    chosenColor = card.color;
  }
  let uno = false;
  if (hands[0].length === 2) {
    if (confirm("Call UNO?")) {
      uno = true;
      unoSaid[0] = true;
      sendMsg({type:'uno'});
    }
  }
  discard.push(card);
  hands[0].splice(i, 1);
  applyCardEffect(card);
  if (hands[0].length === 0) { winner = 0; alert("You win!"); return; }
  mustCallUno[0] = hands[0].length === 1;
  updateUI();
  sendMsg({type:'play', card, idx: i, color: chosenColor, uno});
  turn = 1;
}
function applyCardEffect(card) {
  if (card.value === 'Reverse') dir *= -1;
  else if (card.value === 'Skip') turn = 0;
  else if (card.value === 'Draw2') pendingDraw += 2;
  else if (card.value === 'WildDraw4') pendingDraw += 4;
}
function drawCard() {
  if (turn !== 0 || winner !== -1) return;
  if (pendingDraw > 0) {
    let cards = [];
    for (let i = 0; i < pendingDraw; i++) cards.push(deck.pop());
    hands[0].push(...cards);
    sendMsg({type: 'draw', cards, skip: true});
    pendingDraw = 0;
    turn = 1;
    updateUI();
    return;
  }
  let c = deck.pop();
  hands[0].push(c);
  sendMsg({type:'draw', card:c});
  updateUI();
  turn = 1;
}
function receivePlay(card, idx, color, uno) {
  discard.push(card);
  chosenColor = color;
  hands[1].splice(idx, 1);
  applyCardEffect(card);
  if (hands[1].length === 0) { winner = 1; alert("You lose!"); return; }
  mustCallUno[1] = hands[1].length === 1;
  if (mustCallUno[1] && !uno) {
    for (let i = 0; i < 2; i++) hands[1].push(deck.pop());
    alert("Opponent forgot to call UNO!");
  }
  updateUI();
  turn = 0;
}
function receiveDraw(data) {
  if (data.cards) hands[1].push(...data.cards);
  else hands[1].push(data.card);
  updateUI();
  if (!data.skip) turn = 0;
}
document.getElementById("draw").onclick = drawCard;
function sendMsg(obj) { dc.send(JSON.stringify(obj)); }
function playerId() { return 0; }
let pc = new RTCPeerConnection(), dc = pc.createDataChannel("uno");
dc.onmessage = e => {
  let msg = JSON.parse(e.data);
  if (msg.type === 'play') receivePlay(msg.card, msg.idx, msg.color, msg.uno);
  else if (msg.type === 'draw') receiveDraw(msg);
  else if (msg.type === 'uno') unoSaid[1] = true;
};
pc.onicecandidate = e => {
  if (!pc.iceGatheringState || pc.iceGatheringState === "complete") {
    document.getElementById('localSignal').value = btoa(JSON.stringify(pc.localDescription));
  }
};
pc.ondatachannel = e => {
  dc = e.channel;
  dc.onmessage = dc.onmessage;
};
function connect() {
  document.getElementById("game").style.display = "flex";
  deal(); updateUI();
  if (!document.getElementById("remoteSignal").value) {
    pc.createOffer().then(d => pc.setLocalDescription(d));
  } else {
    let remote = JSON.parse(atob(document.getElementById("remoteSignal").value));
    pc.setRemoteDescription(remote).then(() => {
      if (remote.type === "offer") {
        pc.createAnswer().then(d => pc.setLocalDescription(d));
      }
    });
  }
}
</script>
</body>
</html>
